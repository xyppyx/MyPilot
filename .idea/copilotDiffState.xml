<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/com/javaee/mypilot/infra/agent/PsiHandler.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/javaee/mypilot/infra/agent/PsiHandler.java" />
              <option name="originalContent" value="package com.javaee.mypilot.infra.agent;&#10;&#10;&#10;import com.intellij.openapi.application.ReadAction;&#10;import com.intellij.openapi.components.Service;&#10;import com.intellij.openapi.editor.Document;&#10;import com.intellij.openapi.project.Project;&#10;import com.intellij.openapi.vfs.LocalFileSystem;&#10;import com.intellij.openapi.vfs.VirtualFile;&#10;import com.intellij.openapi.vfs.VirtualFileManager;&#10;import com.intellij.psi.*;&#10;import com.intellij.psi.util.PsiTreeUtil;&#10;import com.intellij.util.concurrency.AppExecutorUtil;&#10;import com.javaee.mypilot.core.model.chat.CodeContext;&#10;import com.javaee.mypilot.core.model.chat.CodeReference;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.concurrent.CompletableFuture;&#10;&#10;/**&#10; * PSI 管理器，负责处理与 PSI（Program Structure Interface）相关的操作，&#10; * 包括代码解析、语法树管理等功能。&#10; */&#10;@Service(Service.Level.PROJECT)&#10;public final class PsiHandler {&#10;&#10;    private final Project project;&#10;&#10;    public PsiHandler(Project project) {&#10;        this.project = project;&#10;    }&#10;&#10;    /**&#10;     * 异步根据代码引用列表，提取对应的代码上下文信息&#10;     * 使用 IntelliJ Platform 的 ReadAction.nonBlocking() 机制&#10;     * 这确保了在正确的线程上下文中访问 PSI 和 VirtualFile&#10;     * &#10;     * @param codeReferences 代码引用列表&#10;     * @return 包含代码上下文列表的异步任务&#10;     */&#10;    public CompletableFuture&lt;List&lt;CodeContext&gt;&gt; fetchCodeContextAsync(List&lt;CodeReference&gt; codeReferences) {&#10;        if (codeReferences == null || codeReferences.isEmpty()) {&#10;            return CompletableFuture.completedFuture(new ArrayList&lt;&gt;());&#10;        }&#10;        &#10;        // 创建 CompletableFuture 来包装 IntelliJ Platform 的异步操作&#10;        CompletableFuture&lt;List&lt;CodeContext&gt;&gt; future = new CompletableFuture&lt;&gt;();&#10;        &#10;        // 使用 IntelliJ Platform 的 ReadAction.nonBlocking() 进行非阻塞读取&#10;        ReadAction.nonBlocking(() -&gt; fetchCodeContext(codeReferences))&#10;            .inSmartMode(project)  // 在智能模式下执行，确保索引已准备好&#10;            .submit(AppExecutorUtil.getAppExecutorService())  // 提交到应用线程池&#10;            .onSuccess(result -&gt; {&#10;                System.out.println(&quot;PsiHandler: 成功提取代码上下文，共 &quot; + result.size() + &quot; 条。&quot;);&#10;                future.complete(result);&#10;            })  // 成功时完成 Future&#10;            .onError(throwable -&gt; future.completeExceptionally(throwable));  // 失败时传递异常&#10;        &#10;        return future;&#10;    }&#10;&#10;    /**&#10;     * 根据代码引用列表，提取对应的代码上下文信息&#10;     * @param codeReferences 代码引用列表&#10;     * @return 代码上下文列表&#10;     */&#10;    public List&lt;CodeContext&gt; fetchCodeContext(List&lt;CodeReference&gt; codeReferences) {&#10;&#10;        List&lt;CodeContext&gt; contexts = new ArrayList&lt;&gt;();&#10;&#10;        if (codeReferences == null || codeReferences.isEmpty()) {&#10;            return contexts;&#10;        }&#10;&#10;        for (CodeReference ref : codeReferences) {&#10;            if (ref == null) continue;&#10;&#10;            CodeContext ctx = new CodeContext();&#10;            ctx.setSourceReference(ref);&#10;&#10;            String selected = ref.getSelectedCode();&#10;            String vurl = ref.getVirtualFileUrl();&#10;&#10;            try {&#10;                VirtualFile vf = null;&#10;                if (vurl != null &amp;&amp; !vurl.isEmpty()) {&#10;                    // 处理 URL 或路径&#10;                    if (vurl.startsWith(&quot;file://&quot;) || vurl.contains(&quot;://&quot;)) {&#10;                        vf = VirtualFileManager.getInstance().findFileByUrl(vurl);&#10;                    } else {&#10;                        vf = LocalFileSystem.getInstance().findFileByPath(vurl);&#10;                    }&#10;                }&#10;&#10;                if (vf != null) {&#10;                    PsiFile psiFile = PsiManager.getInstance(project).findFile(vf);&#10;                    if (psiFile != null) {&#10;                        Document doc = PsiDocumentManager.getInstance(project).getDocument(psiFile);&#10;                        String fileText = psiFile.getText();&#10;&#10;                        // 如果未提供选中代码，则根据偏移量提取&#10;                        if ((selected == null || selected.isEmpty()) &amp;&amp; ref.getStartOffset() &gt;= 0 &amp;&amp; ref.getEndOffset() &gt; ref.getStartOffset()) {&#10;                            int start = Math.max(0, ref.getStartOffset());&#10;                            int end = Math.min(fileText.length(), ref.getEndOffset());&#10;                            if (start &lt; end &amp;&amp; end &lt;= fileText.length()) {&#10;                                selected = fileText.substring(start, end);&#10;                            }&#10;                        }&#10;&#10;                        // 提取上下文代码片段&#10;                        if (doc != null) {&#10;                            int startLine = ref.getStartLine();&#10;                            int endLine = ref.getEndLine();&#10;                            if (startLine &lt;= 0 &amp;&amp; ref.getStartOffset() &gt;= 0) {&#10;                                startLine = doc.getLineNumber(Math.max(0, ref.getStartOffset()));&#10;                            }&#10;                            if (endLine &lt;= 0 &amp;&amp; ref.getEndOffset() &gt; 0) {&#10;                                int off = Math.min(ref.getEndOffset(), Math.max(0, fileText.length() - 1));&#10;                                endLine = doc.getLineNumber(off);&#10;                            }&#10;&#10;                            // 边界检查&#10;                            if (startLine &lt; 0) startLine = 0;&#10;                            if (endLine &lt; startLine) endLine = startLine;&#10;&#10;                            int contextStartLine = Math.max(0, startLine - 5);&#10;                            int contextEndLine = Math.min(doc.getLineCount() - 1, endLine + 5);&#10;&#10;                            int contextStartOffset = doc.getLineStartOffset(contextStartLine);&#10;                            int contextEndOffset = doc.getLineEndOffset(contextEndLine);&#10;&#10;                            // 计算选中代码的起止偏移（优先偏移量，回退到行范围）&#10;                            int selStart = -1;&#10;                            int selEnd = -1;&#10;                            if (ref.getStartOffset() &gt;= 0 &amp;&amp; ref.getEndOffset() &gt; ref.getStartOffset()) {&#10;                                selStart = Math.max(0, ref.getStartOffset());&#10;                                selEnd = Math.min(fileText.length(), ref.getEndOffset());&#10;                            } else if (ref.getStartLine() &gt;= 0 &amp;&amp; ref.getEndLine() &gt;= ref.getStartLine()) {&#10;                                int sl = Math.min(ref.getStartLine(), doc.getLineCount() - 1);&#10;                                int el = Math.min(ref.getEndLine(), doc.getLineCount() - 1);&#10;                                selStart = doc.getLineStartOffset(Math.max(0, sl));&#10;                                selEnd = doc.getLineEndOffset(Math.max(0, el));&#10;                            }&#10;&#10;                            // 与上下文窗口求交集并替换为 &lt;skip selected code&gt;&#10;                            String surrounding;&#10;                            if (selStart &gt;= 0 &amp;&amp; selEnd &gt; selStart &amp;&amp; !(selEnd &lt;= contextStartOffset || selStart &gt;= contextEndOffset)) {&#10;                                int prefixStart = contextStartOffset;&#10;                                int prefixEnd = Math.max(contextStartOffset, selStart);&#10;                                int suffixStart = Math.min(contextEndOffset, selEnd);&#10;                                int suffixEnd = contextEndOffset;&#10;&#10;                                String prefix = fileText.substring(prefixStart, prefixEnd);&#10;                                String suffix = fileText.substring(suffixStart, suffixEnd);&#10;                                surrounding = prefix + &quot;&lt;skip selected code&gt;&quot; + suffix;&#10;                            } else {&#10;                                // 选中范围无效或不在上下文窗口内，直接返回上下文&#10;                                surrounding = fileText.substring(contextStartOffset, contextEndOffset);&#10;                            }&#10;&#10;                            ctx.setSurroundingCode(surrounding);&#10;                        } else {&#10;                            // 无法获取 Document，使用整个文件内容作为上下文&#10;                            ctx.setSurroundingCode(fileText);&#10;                        }&#10;&#10;                        ctx.setFileName(vf.getName());&#10;&#10;                        // 获取 package 名称&#10;                        PsiPackageStatement pkg = PsiTreeUtil.findChildOfType(psiFile, PsiPackageStatement.class);&#10;                        if (pkg != null) {&#10;                            ctx.setPackageName(pkg.getPackageName());&#10;                        }&#10;&#10;                        // 获取 class 和 method 名称&#10;                        int elementOffset = Math.max(0, ref.getStartOffset());&#10;                        if (elementOffset &gt;= fileText.length()) elementOffset = Math.max(0, fileText.length() - 1);&#10;                        PsiElement el = psiFile.findElementAt(elementOffset);&#10;                        if (el != null) {&#10;                            PsiClass cls = PsiTreeUtil.getParentOfType(el, PsiClass.class);&#10;                            if (cls != null) ctx.setClassName(cls.getName());&#10;&#10;                            PsiMethod method = PsiTreeUtil.getParentOfType(el, PsiMethod.class);&#10;                            if (method != null) ctx.setMethodName(method.getName());&#10;                        }&#10;&#10;                    } else {&#10;                        // 无法解析 PSI 文件, 仅设置选中代码和文件名&#10;                        ctx.setFileName(vf.getName());&#10;                    }&#10;                } else {&#10;                    // 无法找到虚拟文件, 仅设置选中代码&#10;                    if (vurl != null) ctx.setFileName(vurl);&#10;                }&#10;            } catch (Exception e) {&#10;                // 处理异常，继续下一个引用&#10;                System.err.println(&quot;PsiHandler: 处理代码引用时出错: &quot; + e.getMessage());&#10;            }&#10;&#10;            contexts.add(ctx);&#10;        }&#10;&#10;        return contexts;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.javaee.mypilot.infra.agent;&#10;&#10;&#10;import com.intellij.openapi.application.ReadAction;&#10;import com.intellij.openapi.components.Service;&#10;import com.intellij.openapi.editor.Document;&#10;import com.intellij.openapi.project.Project;&#10;import com.intellij.openapi.vfs.LocalFileSystem;&#10;import com.intellij.openapi.vfs.VirtualFile;&#10;import com.intellij.openapi.vfs.VirtualFileManager;&#10;import com.intellij.psi.*;&#10;import com.intellij.psi.util.PsiTreeUtil;&#10;import com.intellij.util.concurrency.AppExecutorUtil;&#10;import com.javaee.mypilot.core.model.chat.CodeContext;&#10;import com.javaee.mypilot.core.model.chat.CodeReference;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.concurrent.CompletableFuture;&#10;&#10;/**&#10; * PSI 管理器，负责处理与 PSI（Program Structure Interface）相关的操作，&#10; * 包括代码解析、语法树管理等功能。&#10; */&#10;@Service(Service.Level.PROJECT)&#10;public final class PsiHandler {&#10;&#10;    private final Project project;&#10;&#10;    public PsiHandler(Project project) {&#10;        this.project = project;&#10;    }&#10;&#10;    /**&#10;     * 异步根据代码引用列表，提取对应的代码上下文信息&#10;     * 使用 IntelliJ Platform 的 ReadAction.nonBlocking() 机制&#10;     * 这确保了在正确的线程上下文中访问 PSI 和 VirtualFile&#10;     * &#10;     * @param codeReferences 代码引用列表&#10;     * @return 包含代码上下文列表的异步任务&#10;     */&#10;    public CompletableFuture&lt;List&lt;CodeContext&gt;&gt; fetchCodeContextAsync(List&lt;CodeReference&gt; codeReferences) {&#10;        if (codeReferences == null || codeReferences.isEmpty()) {&#10;            return CompletableFuture.completedFuture(new ArrayList&lt;&gt;());&#10;        }&#10;        &#10;        // 创建 CompletableFuture 来包装 IntelliJ Platform 的异步操作&#10;        CompletableFuture&lt;List&lt;CodeContext&gt;&gt; future = new CompletableFuture&lt;&gt;();&#10;        &#10;        // 使用 IntelliJ Platform 的 ReadAction.nonBlocking() 进行非阻塞读取&#10;        ReadAction.nonBlocking(() -&gt; fetchCodeContext(codeReferences))&#10;            .inSmartMode(project)  // 在智能模式下执行，确保索引已准备好&#10;            .submit(AppExecutorUtil.getAppExecutorService())  // 提交到应用线程池&#10;            .onSuccess(result -&gt; {&#10;                System.out.println(&quot;PsiHandler: 成功提取代码上下文，共 &quot; + result.size() + &quot; 条。&quot;);&#10;                future.complete(result);&#10;            })  // 成功时完成 Future&#10;            .onError(throwable -&gt; future.completeExceptionally(throwable));  // 失败时传递异常&#10;        &#10;        return future;&#10;    }&#10;&#10;    /**&#10;     * 根据代码引用列表，提取对应的代码上下文信息&#10;     * @param codeReferences 代码引用列表&#10;     * @return 代码上下文列表&#10;     */&#10;    public List&lt;CodeContext&gt; fetchCodeContext(List&lt;CodeReference&gt; codeReferences) {&#10;&#10;        List&lt;CodeContext&gt; contexts = new ArrayList&lt;&gt;();&#10;&#10;        if (codeReferences == null || codeReferences.isEmpty()) {&#10;            return contexts;&#10;        }&#10;&#10;        for (CodeReference ref : codeReferences) {&#10;            if (ref == null) continue;&#10;&#10;            CodeContext ctx = new CodeContext();&#10;            ctx.setSourceReference(ref);&#10;&#10;            String selected = ref.getSelectedCode();&#10;            String vurl = ref.getVirtualFileUrl();&#10;&#10;            try {&#10;                VirtualFile vf = null;&#10;                if (vurl != null &amp;&amp; !vurl.isEmpty()) {&#10;                    // 处理 URL 或路径&#10;                    if (vurl.startsWith(&quot;file://&quot;) || vurl.contains(&quot;://&quot;)) {&#10;                        vf = VirtualFileManager.getInstance().findFileByUrl(vurl);&#10;                    } else {&#10;                        vf = LocalFileSystem.getInstance().findFileByPath(vurl);&#10;                    }&#10;                }&#10;&#10;                if (vf != null) {&#10;                    PsiFile psiFile = PsiManager.getInstance(project).findFile(vf);&#10;                    if (psiFile != null) {&#10;                        Document doc = PsiDocumentManager.getInstance(project).getDocument(psiFile);&#10;                        String fileText = psiFile.getText();&#10;&#10;                        // 如果未提供选中代码，则根据偏移量提取&#10;                        if ((selected == null || selected.isEmpty()) &amp;&amp; ref.getStartOffset() &gt;= 0 &amp;&amp; ref.getEndOffset() &gt; ref.getStartOffset()) {&#10;                            int start = Math.max(0, ref.getStartOffset());&#10;                            int end = Math.min(fileText.length(), ref.getEndOffset());&#10;                            if (start &lt; end &amp;&amp; end &lt;= fileText.length()) {&#10;                                selected = fileText.substring(start, end);&#10;                            }&#10;                        }&#10;&#10;                        // 提取上下文代码片段&#10;                        if (doc != null) {&#10;                            int startLine = ref.getStartLine();&#10;                            int endLine = ref.getEndLine();&#10;                            if (startLine &lt;= 0 &amp;&amp; ref.getStartOffset() &gt;= 0) {&#10;                                startLine = doc.getLineNumber(Math.max(0, ref.getStartOffset()));&#10;                            }&#10;                            if (endLine &lt;= 0 &amp;&amp; ref.getEndOffset() &gt; 0) {&#10;                                int off = Math.min(ref.getEndOffset(), Math.max(0, fileText.length() - 1));&#10;                                endLine = doc.getLineNumber(off);&#10;                            }&#10;&#10;                            // 边界检查&#10;                            if (startLine &lt; 0) startLine = 0;&#10;                            if (endLine &lt; startLine) endLine = startLine;&#10;&#10;                            int contextStartLine = Math.max(0, startLine - 5);&#10;                            int contextEndLine = Math.min(doc.getLineCount() - 1, endLine + 5);&#10;&#10;                            int contextStartOffset = doc.getLineStartOffset(contextStartLine);&#10;                            int contextEndOffset = doc.getLineEndOffset(contextEndLine);&#10;&#10;                            // 计算选中代码的起止偏移（优先偏移量，回退到行范围）&#10;                            int selStart = -1;&#10;                            int selEnd = -1;&#10;                            if (ref.getStartOffset() &gt;= 0 &amp;&amp; ref.getEndOffset() &gt; ref.getStartOffset()) {&#10;                                selStart = Math.max(0, ref.getStartOffset());&#10;                                selEnd = Math.min(fileText.length(), ref.getEndOffset());&#10;                            } else if (ref.getStartLine() &gt;= 0 &amp;&amp; ref.getEndLine() &gt;= ref.getStartLine()) {&#10;                                int sl = Math.min(ref.getStartLine(), doc.getLineCount() - 1);&#10;                                int el = Math.min(ref.getEndLine(), doc.getLineCount() - 1);&#10;                                selStart = doc.getLineStartOffset(Math.max(0, sl));&#10;                                selEnd = doc.getLineEndOffset(Math.max(0, el));&#10;                            }&#10;&#10;                            // 与上下文窗口求交集并替换为 &lt;skip selected code&gt;&#10;                            String surrounding;&#10;                            if (selStart &gt;= 0 &amp;&amp; selEnd &gt; selStart &amp;&amp; !(selEnd &lt;= contextStartOffset || selStart &gt;= contextEndOffset)) {&#10;                                int prefixStart = contextStartOffset;&#10;                                int prefixEnd = Math.max(contextStartOffset, selStart);&#10;                                int suffixStart = Math.min(contextEndOffset, selEnd);&#10;                                int suffixEnd = contextEndOffset;&#10;&#10;                                String prefix = fileText.substring(prefixStart, prefixEnd);&#10;                                String suffix = fileText.substring(suffixStart, suffixEnd);&#10;                                surrounding = prefix + &quot;&lt;skip selected code&gt;&quot; + suffix;&#10;                            } else {&#10;                                // 选中范围无效或不在上下文窗口内，直接返回上下文&#10;                                surrounding = fileText.substring(contextStartOffset, contextEndOffset);&#10;                            }&#10;&#10;                            ctx.setSurroundingCode(surrounding);&#10;                        } else {&#10;                            // 无法获取 Document，使用整个文件内容作为上下文&#10;                            ctx.setSurroundingCode(fileText);&#10;                        }&#10;&#10;                        ctx.setFileName(vf.getName());&#10;&#10;                        // 获取 package 名称&#10;                        PsiPackageStatement pkg = PsiTreeUtil.findChildOfType(psiFile, PsiPackageStatement.class);&#10;                        if (pkg != null) {&#10;                            ctx.setPackageName(pkg.getPackageName());&#10;                        }&#10;&#10;                        // 获取 class 和 method 名称&#10;                        int elementOffset = Math.max(0, ref.getStartOffset());&#10;                        if (elementOffset &gt;= fileText.length()) elementOffset = Math.max(0, fileText.length() - 1);&#10;                        PsiElement el = psiFile.findElementAt(elementOffset);&#10;                        if (el != null) {&#10;                            PsiClass cls = PsiTreeUtil.getParentOfType(el, PsiClass.class);&#10;                            if (cls != null) ctx.setClassName(cls.getName());&#10;&#10;                            PsiMethod method = PsiTreeUtil.getParentOfType(el, PsiMethod.class);&#10;                            if (method != null) ctx.setMethodName(method.getName());&#10;                        }&#10;&#10;                    } else {&#10;                        // 无法解析 PSI 文件, 仅设置选中代码和文件名&#10;                        ctx.setFileName(vf.getName());&#10;                    }&#10;                } else {&#10;                    // 无法找到虚拟文件, 仅设置选中代码&#10;                    if (vurl != null) ctx.setFileName(vurl);&#10;                }&#10;            } catch (Exception e) {&#10;                // 处理异常，继续下一个引用&#10;                System.err.println(&quot;PsiHandler: 处理代码引用时出错: &quot; + e.getMessage());&#10;            }&#10;&#10;            contexts.add(ctx);&#10;        }&#10;&#10;        return contexts;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>