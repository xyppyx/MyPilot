<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/com/javaee/mypilot/infra/rag/PDFDocumentProcessor.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/javaee/mypilot/infra/rag/PDFDocumentProcessor.java" />
              <option name="originalContent" value="package com.javaee.mypilot.infra.rag;&#10;&#10;import com.javaee.mypilot.core.model.rag.DocumentChunk;&#10;import com.javaee.mypilot.infra.rag.embedding.EmbeddingService;&#10;import org.apache.pdfbox.pdmodel.PDDocument;&#10;import org.apache.pdfbox.text.PDFTextStripper;&#10;&#10;import java.io.File;&#10;import java.io.IOException;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.UUID;&#10;&#10;/**&#10; * 使用 Apache PDFBox 解析 PDF 文件的 DocumentProcessor 实现&#10; */&#10;public class PDFDocumentProcessor implements DocumentProcessor {&#10;    private final EmbeddingService embeddingService;&#10;    private static final int CHUNK_SIZE = 1000; // 每个chunk的字符数&#10;&#10;    public PDFDocumentProcessor(EmbeddingService embeddingService) {&#10;        this.embeddingService = embeddingService;&#10;    }&#10;&#10;    @Override&#10;    public List&lt;DocumentChunk&gt; process(File file) {&#10;        List&lt;DocumentChunk&gt; chunks = new ArrayList&lt;&gt;();&#10;&#10;        try (PDDocument document = PDDocument.load(file)) {&#10;            PDFTextStripper stripper = new PDFTextStripper();&#10;            int totalPages = document.getNumberOfPages();&#10;&#10;            // 按页处理PDF&#10;            for (int pageNum = 1; pageNum &lt;= totalPages; pageNum++) {&#10;                stripper.setStartPage(pageNum);&#10;                stripper.setEndPage(pageNum);&#10;                String pageText = stripper.getText(document).trim();&#10;&#10;                if (!pageText.isEmpty()) {&#10;                    // 如果页面内容较长，可以进一步分块&#10;                    List&lt;String&gt; pageChunks = splitIntoChunks(pageText, CHUNK_SIZE);&#10;&#10;                    for (int i = 0; i &lt; pageChunks.size(); i++) {&#10;                        String chunkContent = pageChunks.get(i);&#10;                        float[] embedding = embeddingService.embed(chunkContent);&#10;&#10;                        // 生成标题：如果是单块则用页码，多块则加上块序号&#10;                        String title = pageChunks.size() == 1&#10;                            ? &quot;第&quot; + pageNum + &quot;页&quot;&#10;                            : &quot;第&quot; + pageNum + &quot;页-块&quot; + (i + 1);&#10;&#10;                        DocumentChunk chunk = new DocumentChunk(&#10;                                UUID.randomUUID().toString(),&#10;                                chunkContent,&#10;                                file.getName(),&#10;                                pageNum,&#10;                                title,&#10;                                embedding);&#10;                        chunks.add(chunk);&#10;                    }&#10;                }&#10;            }&#10;        } catch (IOException e) {&#10;            throw new RuntimeException(&quot;解析PDF文件失败: &quot; + file.getName(), e);&#10;        }&#10;&#10;        return chunks;&#10;    }&#10;&#10;    /**&#10;     * 将长文本分割成多个块&#10;     */&#10;    private List&lt;String&gt; splitIntoChunks(String text, int chunkSize) {&#10;        List&lt;String&gt; chunks = new ArrayList&lt;&gt;();&#10;&#10;        if (text.length() &lt;= chunkSize) {&#10;            chunks.add(text);&#10;            return chunks;&#10;        }&#10;&#10;        // 按段落分割&#10;        String[] paragraphs = text.split(&quot;\n\n&quot;);&#10;        StringBuilder currentChunk = new StringBuilder();&#10;&#10;        for (String paragraph : paragraphs) {&#10;            if (currentChunk.length() + paragraph.length() &gt; chunkSize &amp;&amp; currentChunk.length() &gt; 0) {&#10;                chunks.add(currentChunk.toString().trim());&#10;                currentChunk = new StringBuilder();&#10;            }&#10;            currentChunk.append(paragraph).append(&quot;\n\n&quot;);&#10;        }&#10;&#10;        if (currentChunk.length() &gt; 0) {&#10;            chunks.add(currentChunk.toString().trim());&#10;        }&#10;&#10;        return chunks;&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.javaee.mypilot.infra.rag;&#13;&#10;&#13;&#10;import com.javaee.mypilot.core.model.rag.DocumentChunk;&#13;&#10;import com.javaee.mypilot.infra.rag.embedding.EmbeddingService;&#13;&#10;import org.apache.pdfbox.pdmodel.PDDocument;&#13;&#10;import org.apache.pdfbox.text.PDFTextStripper;&#13;&#10;&#13;&#10;import java.io.File;&#13;&#10;import java.io.IOException;&#13;&#10;import java.util.ArrayList;&#13;&#10;import java.util.List;&#13;&#10;import java.util.UUID;&#13;&#10;&#13;&#10;/**&#10; * 使用 Apache PDFBox 解析 PDF 文件的 DocumentProcessor 实现&#10; */&#10;public class PDFDocumentProcessor implements DocumentProcessor {&#10;    private final EmbeddingService embeddingService;&#10;    private static final int CHUNK_SIZE = 1000; // 每个chunk的字符数&#10;&#10;    public PDFDocumentProcessor(EmbeddingService embeddingService) {&#10;        this.embeddingService = embeddingService;&#10;    }&#10;&#10;    @Override&#10;    public List&lt;DocumentChunk&gt; process(File file) {&#10;        return process(file, DocumentChunk.SourceType.USER_UPLOADED);&#10;    }&#10;&#10;    /**&#10;     * 处理 PDF 文件，支持指定来源类型&#10;     * @param file PDF 文件&#10;     * @param sourceType 来源类型（静态资源或用户上传）&#10;     * @return 文档块列表&#10;     */&#10;    public List&lt;DocumentChunk&gt; process(File file, DocumentChunk.SourceType sourceType) {&#10;        List&lt;DocumentChunk&gt; chunks = new ArrayList&lt;&gt;();&#10;&#10;        try (PDDocument document = PDDocument.load(file)) {&#10;            PDFTextStripper stripper = new PDFTextStripper();&#10;            int totalPages = document.getNumberOfPages();&#10;&#10;            // 按页处理PDF&#10;            for (int pageNum = 1; pageNum &lt;= totalPages; pageNum++) {&#10;                stripper.setStartPage(pageNum);&#10;                stripper.setEndPage(pageNum);&#10;                String pageText = stripper.getText(document).trim();&#10;&#10;                if (!pageText.isEmpty()) {&#10;                    // 如果页面内容较长，可以进一步分块&#10;                    List&lt;String&gt; pageChunks = splitIntoChunks(pageText, CHUNK_SIZE);&#10;&#10;                    for (int i = 0; i &lt; pageChunks.size(); i++) {&#10;                        String chunkContent = pageChunks.get(i);&#10;                        float[] embedding = embeddingService.embed(chunkContent);&#10;&#10;                        // 生成标题：如果是单块则用页码，多块则加上块序号&#10;                        String title = pageChunks.size() == 1&#10;                            ? &quot;第&quot; + pageNum + &quot;页&quot;&#10;                            : &quot;第&quot; + pageNum + &quot;页-块&quot; + (i + 1);&#10;&#10;                        DocumentChunk chunk = new DocumentChunk(&#10;                                UUID.randomUUID().toString(),&#10;                                chunkContent,&#10;                                file.getName(),&#10;                                pageNum,&#10;                                title,&#10;                                embedding,&#10;                                sourceType);&#13;&#10;                        chunks.add(chunk);&#13;&#10;                    }&#13;&#10;                }&#13;&#10;            }&#13;&#10;        } catch (IOException e) {&#13;&#10;            throw new RuntimeException(&quot;解析PDF文件失败: &quot; + file.getName(), e);&#13;&#10;        }&#13;&#10;&#13;&#10;        return chunks;&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * 将长文本分割成多个块&#13;&#10;     */&#13;&#10;    private List&lt;String&gt; splitIntoChunks(String text, int chunkSize) {&#13;&#10;        List&lt;String&gt; chunks = new ArrayList&lt;&gt;();&#13;&#10;&#13;&#10;        if (text.length() &lt;= chunkSize) {&#13;&#10;            chunks.add(text);&#13;&#10;            return chunks;&#13;&#10;        }&#13;&#10;&#13;&#10;        // 按段落分割&#13;&#10;        String[] paragraphs = text.split(&quot;\n\n&quot;);&#13;&#10;        StringBuilder currentChunk = new StringBuilder();&#13;&#10;&#13;&#10;        for (String paragraph : paragraphs) {&#13;&#10;            if (currentChunk.length() + paragraph.length() &gt; chunkSize &amp;&amp; currentChunk.length() &gt; 0) {&#13;&#10;                chunks.add(currentChunk.toString().trim());&#13;&#10;                currentChunk = new StringBuilder();&#13;&#10;            }&#13;&#10;            currentChunk.append(paragraph).append(&quot;\n\n&quot;);&#13;&#10;        }&#13;&#10;&#13;&#10;        if (currentChunk.length() &gt; 0) {&#13;&#10;            chunks.add(currentChunk.toString().trim());&#13;&#10;        }&#13;&#10;&#13;&#10;        return chunks;&#13;&#10;    }&#13;&#10;}&#13;&#10;&#13;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/javaee/mypilot/infra/rag/PPTDocumentProcessor.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/javaee/mypilot/infra/rag/PPTDocumentProcessor.java" />
              <option name="originalContent" value="package com.javaee.mypilot.infra.rag;&#10;&#10;import com.javaee.mypilot.core.model.rag.DocumentChunk;&#10;import com.javaee.mypilot.infra.rag.embedding.EmbeddingService;&#10;import org.apache.poi.xslf.usermodel.XMLSlideShow;&#10;import org.apache.poi.xslf.usermodel.XSLFShape;&#10;import org.apache.poi.xslf.usermodel.XSLFSlide;&#10;import org.apache.poi.xslf.usermodel.XSLFTextShape;&#10;&#10;import java.io.File;&#10;import java.io.FileInputStream;&#10;import java.io.IOException;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.UUID;&#10;&#10;/**&#10; * 使用 Apache POI 解析 PPTX 文件的 DocumentProcessor 实现&#10; */&#10;public class PPTDocumentProcessor implements DocumentProcessor {&#10;    private final EmbeddingService embeddingService;&#10;&#10;    public PPTDocumentProcessor(EmbeddingService embeddingService) {&#10;        this.embeddingService = embeddingService;&#10;    }&#10;&#10;    @Override&#10;    public List&lt;DocumentChunk&gt; process(File file) {&#10;        List&lt;DocumentChunk&gt; chunks = new ArrayList&lt;&gt;();&#10;        try (FileInputStream fis = new FileInputStream(file);&#10;             XMLSlideShow ppt = new XMLSlideShow(fis)) {&#10;            List&lt;XSLFSlide&gt; slides = ppt.getSlides();&#10;            for (int i = 0; i &lt; slides.size(); i++) {&#10;                XSLFSlide slide = slides.get(i);&#10;                StringBuilder text = new StringBuilder();&#10;                String title = slide.getTitle();&#10;                for (XSLFShape shape : slide.getShapes()) {&#10;                    if (shape instanceof XSLFTextShape textShape) {&#10;                        text.append(textShape.getText()).append(&quot;\n&quot;);&#10;                    }&#10;                }&#10;                String content = text.toString().trim();&#10;                if (!content.isEmpty()) {&#10;                    float[] embedding = embeddingService.embed(content);&#10;                    DocumentChunk chunk = new DocumentChunk(&#10;                            UUID.randomUUID().toString(),&#10;                            content,&#10;                            file.getName(),&#10;                            i + 1, // 页码从1开始&#10;                            title,&#10;                            embedding);&#10;                    chunks.add(chunk);&#10;                }&#10;            }&#10;        } catch (IOException e) {&#10;            throw new RuntimeException(&quot;解析PPT文件失败: &quot; + file.getName(), e);&#10;        }&#10;        return chunks;&#10;    }&#10;}&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="package com.javaee.mypilot.infra.rag;&#13;&#10;&#13;&#10;import com.javaee.mypilot.core.model.rag.DocumentChunk;&#13;&#10;import com.javaee.mypilot.infra.rag.embedding.EmbeddingService;&#13;&#10;import org.apache.poi.xslf.usermodel.XMLSlideShow;&#13;&#10;import org.apache.poi.xslf.usermodel.XSLFShape;&#13;&#10;import org.apache.poi.xslf.usermodel.XSLFSlide;&#13;&#10;import org.apache.poi.xslf.usermodel.XSLFTextShape;&#13;&#10;&#13;&#10;import java.io.File;&#13;&#10;import java.io.FileInputStream;&#13;&#10;import java.io.IOException;&#13;&#10;import java.util.ArrayList;&#13;&#10;import java.util.List;&#13;&#10;import java.util.UUID;&#13;&#10;&#13;&#10;/**&#10; * 使用 Apache POI 解析 PPTX 文件的 DocumentProcessor 实现&#10; */&#10;public class PPTDocumentProcessor implements DocumentProcessor {&#10;    private final EmbeddingService embeddingService;&#10;&#10;    public PPTDocumentProcessor(EmbeddingService embeddingService) {&#10;        this.embeddingService = embeddingService;&#10;    }&#10;&#10;    @Override&#10;    public List&lt;DocumentChunk&gt; process(File file) {&#10;        return process(file, DocumentChunk.SourceType.USER_UPLOADED);&#10;    }&#10;&#10;    /**&#10;     * 处理 PPT 文件，支持指定来源类型&#10;     * @param file PPT 文件&#10;     * @param sourceType 来源类型（静态资源或用户上传）&#10;     * @return 文档块列表&#10;     */&#10;    public List&lt;DocumentChunk&gt; process(File file, DocumentChunk.SourceType sourceType) {&#10;        List&lt;DocumentChunk&gt; chunks = new ArrayList&lt;&gt;();&#10;        try (FileInputStream fis = new FileInputStream(file);&#10;             XMLSlideShow ppt = new XMLSlideShow(fis)) {&#10;            List&lt;XSLFSlide&gt; slides = ppt.getSlides();&#10;            for (int i = 0; i &lt; slides.size(); i++) {&#10;                XSLFSlide slide = slides.get(i);&#10;                StringBuilder text = new StringBuilder();&#10;                String title = slide.getTitle();&#10;                for (XSLFShape shape : slide.getShapes()) {&#10;                    if (shape instanceof XSLFTextShape textShape) {&#10;                        text.append(textShape.getText()).append(&quot;\n&quot;);&#10;                    }&#10;                }&#10;                String content = text.toString().trim();&#10;                if (!content.isEmpty()) {&#10;                    float[] embedding = embeddingService.embed(content);&#10;                    DocumentChunk chunk = new DocumentChunk(&#10;                            UUID.randomUUID().toString(),&#10;                            content,&#10;                            file.getName(),&#10;                            i + 1, // 页码从1开始&#10;                            title,&#10;                            embedding,&#10;                            sourceType);&#13;&#10;                    chunks.add(chunk);&#13;&#10;                }&#13;&#10;            }&#13;&#10;        } catch (IOException e) {&#13;&#10;            throw new RuntimeException(&quot;解析PPT文件失败: &quot; + file.getName(), e);&#13;&#10;        }&#13;&#10;        return chunks;&#13;&#10;    }&#13;&#10;}&#13;&#10;&#13;&#10;&#13;&#10;&#13;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>